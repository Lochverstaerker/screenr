#!/bin/bash

# This script takes a screenshot using maim (+ slop) and then prompts the user what to do with it using rofi.
# Available options are "Save", "Upload" (to imgur and dropbox), "Edit", "Save & Upload" and "View"
# Available flags are all the maim flags (not sure if all of them work though), except --help and -V (--version), which are handled by this script.

### CONFIGURATION - Feel free to edit this ###
#
#Directory to save images to | must exist
image_dir="$HOME/Pictures/Screenshots"
#Dropbox directory to save images to | must exist
db_dir="$HOME/Dropbox/Public/Screenshots"
#Whether or not to wait until a file is uploaded, before opening it in web browser,
#when using dropbox
#0 for no, anything else is a yes
db_waiting=1
#frequency at which to check if file is already synced
#high values need (slightly) more computational power but waiting time is (slightly) reduced
#only in effect if db_waiting is not 0
check_interval=0.1
#Whether or not there is a log;
#logs all images uploaded (with date) and if uploaded to imgur also includes 'Delete link'
#0 for no, anything else is a yes
logging=0
#Path to logfile (logs URLs to images and to delete uploads); gets created if it does not exist and logging is enabled
log_file="$HOME/Pictures/Screenshots/log"
#Whether or not URL of upload gets clipped (copied into clipboard)
#0 for no, anything else is a yes
#requires xsel or xclip
clipping=1
#Formatting of date and image name; must be preciise enough to be unique
date_format="+%F-%T"
#Image format
img_format="png"
#Browser to open uploaded images with
#"xdg-open" for default/favorite browser
#leave blank or comment to not open uploads automatically in browser
browser="xdg-open"
#Image Manipulation Program
img_prg="pinta"
#Image Viewer
img_view="feh -F"
#
### ###

# TODO:
#       Re-add option to use scrot (to screen transparency of window)
#       Add better formatting options
#           For file name (not including date; use maim -f)
#           Append something to file name if image was edited (optionally)
#           Add option to append image dimensions to file name (optionally)
#       Flags
#           Improve flags to skip menu and get desired result immediately
#           Throw error on bogus flags
#       (Start pinta in fullscreen) (If possible)
#       Improve logging (How?)
#       (Optionally) wait on dropbox filestatus and inform when file is up
#       Check if necessary/specified directories exist
#       (Distinguish between dropbox and imgur in the configuration)

# Don't touch anything below, unless you know what you're doing

function usage {
    cat << EOF
screenr - a rofi-driven screenshot tool

https://github.com/Lochverstaerker/screenr

Usage: screenr [options]

screenr is a utility that takes screenshots using maim (+ slop)
and then opens a rofi-driven interactive menu to let the user decide what to do with the screenshot.

    -h, --help                      Show this information and exit
    -V, --version                   Show version information and exit
Options
        --upload UPLOADER           Skip the interactive menu and upload directly
                                        to UPLOADER (imgur or dropbox).
        --save                      Skip the interactive menu and save directly.
Additional Options
        (Almost) all the maim (+ slop) Options, see maim --help or man maim for help

Examples
    $ # Screenshot a selection and open interactive menu
    $ screenr -s

    $ # Screenshot the screen and save it, without opening interactive menu
    $ screenr --save

    $ # Screenshot currently active window and upload it to imgur
    $ screenr -i \$(xdotool getactivewindow) --upload imgur
EOF
}

# Cleans up all the temporary files created during this script
function cleanup {
    shred -u /tmp/screenr/*
    rm -r /tmp/screenr
}

# Saves the screenshot to the image directory of the user
function save {
    cp "$full_path" "$image_dir"
    notify-send -u normal "Image saved" "$image_name"
}

# Must be called (immediately) after setting "$url_name";
# If a browser is defined in the config, this opens "$url_name" with it
function open_in_browser {
    if [ ! -z "$browser" ]; then
        if hash $(echo "$browser" | cut -f 1 -d " ") 2>/dev/null; then
            $browser $url_name
        else
            echo "Web browser not found." >&2
        fi
    fi
}

# If imgur is installed, this uploads the screenshot to it; otherwise an error is displayed in STDERR
# Optionally the site is opened in a web browser
function imgur_upload {
    if hash imgur 2>/dev/null; then
        imgur "$full_path" > /tmp/screenr/tmp_url 2> /tmp/screenr/tmp_url_del
        url_name=$(head -n 1 < /tmp/screenr/tmp_url)
        notify-send -u normal "Image uploaded" "$url_name"
        open_in_browser
    else
        echo "Can't upload to imgur, because the necessary script can't be found" >&2
    fi
}

# Copies the screenshot into the users dropbox directory, if dropbox-cli is installed there is added (optional) functionality:
# Tries to get puburl and if that is not possible gets sharelink, then (optionally) copies that into clipboard and opens it in web browser
function dropbox_upload {
    cp "$full_path" "$db_dir"
    printf "$db_dir/" >> "/tmp/screenr/db_path"; printf "$image_name" >> "/tmp/screenr/db_path"
    db_path=$(</tmp/screenr/db_path)
    notify-send -u normal "Image copied into dropbox" "$image_name"
    if hash dropbox-cli 2>/dev/null; then
        dropbox-cli puburl "$db_path" > /tmp/screenr/tmp_url
        if [[ $(grep "Error" < /tmp/screenr/tmp_url) ]]; then
            dropbox-cli sharelink "$db_path" > /tmp/screenr/tmp_url
        fi
        url_name=$(</tmp/screenr/tmp_url)
        if [[ "$db_waiting" -ne 0 ]]; then
            while [[ $(dropbox-cli filestatus "$db_path" | grep "syncing") ]]; do
                sleep "$check_interval"
            done
        fi
            open_in_browser
    else
        echo "Can't make use of additional dropbox related functionality, because the necessary script can't be found" >&2
    fi
}

# Menu to decide about where to upload screenshot; ESC or back cancels and goes back to (the previous) menu
# "$@" for added functionality to 'Retake' screenshots
function upload_menu {
    if [[ -z "$uploader" ]]; then #if ESC is pressed variable is not initialized
        uploader="$uploader_"     #falls back to default value
    fi
    if [[ $uploader == "Imgur" ]]; then
        imgur_upload
    fi
    if [[ $uploader == "Dropbox" ]]; then
        dropbox_upload
    fi
    if [[ $uploader == "Back" ]]; then
        unset choice
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nDiscard" | rofi -dmenu -p "Screenshot taken. What now? > ")
        menu "$@"
    fi
    if [[ $uploader == "Exit" ]]; then
        cleanup
        exit 0
    fi
}

# Makes a screenshot with specified flags; if -s is provided and interrupted by a keyboard interrupt, this cancels the script
function take_screenshot {
    if [[ $selection_mode == "1" ]]; then
        notify-send -t 1 -u low "Entered Screenshot Selection Mode"
    fi
    maim "$@" "$full_path" 2> /tmp/screenr/maim_err
    if [[ $(grep "Canceled selection" < /tmp/screenr/maim_err) ]]; then
        notify-send -t 1 -u low "Canceled"
        cleanup
        exit 0
    fi
    if [[ $(grep "invalid" < /tmp/screenr/maim_err) ]]; then
        cat /tmp/screenr/maim_err >&2
        echo "Maim encountered an error. Aborting" >&2
        exit 1
    fi
}

# Menu to decide what to do
# "$@" for added functionality to 'Retake' screenshots
# Every time a program is called, it is first checked if it exists and if not an error is directed to STDERR
function menu {
    if [[ $choice == "Save" ]]; then
        save
    fi
    if [[ $choice == "Upload" ]]; then
        unset uploader
        uploader=$(echo -e "Imgur\nDropbox\nBack" | rofi -dmenu -p "Where to upload? > ")
        uploader_="Back" #default choice
        upload_menu "$@"
    fi
    if [[ $choice == "Edit" ]]; then
        if hash $(echo "$img_prg" | cut -f 1 -d " ") 2>/dev/null; then #cut to remove flags that may be passed with the program
            $img_prg "$full_path"
        else
            echo "Image Manipulation Program not found" >&2
        fi
        unset choice
        choice=$(echo -e "Save\nUpload\nSave & Upload\nView\nDiscard" | rofi -dmenu -p "Image edited. What now? > ")
        menu "$@"
    fi
    if [[ $choice == "Save & Upload" ]]; then
        save
        uploader=$(echo -e "Imgur\nDropbox\nExit" | rofi -dmenu -p "Where to upload? > ")
        uploader_="Exit" #default choice
        upload_menu "$@"
    fi
    if [[ $choice == "View" ]]; then
        if hash $(echo "$img_view" | cut -f 1 -d " ") 2>/dev/null; then #cut to remove flags that may be passed with the program
            $img_view "$full_path"
        else
            echo "Image Viewer not found" >&2
        fi
        unset choice
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nRetake\nDiscard" | rofi -dmenu -p "What now? > ")
        menu "$@"
    fi
    if [[ $choice == "Retake" ]]; then
        take_screenshot "$@"
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nRetake\nDiscard" | rofi -dmenu -p "Screenshot taken. What now? > ")
        menu "$@"
    fi
    if [[ $choice == "Discard" || -z "$choice" ]]; then
        notify-send -u normal "Image discarded"
        cleanup
        exit 0
    fi
}

# Checks for certain flags that are handled by the script itself and not by maim
while test $# -gt 0; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -V|--version)
            echo "screenr v0.3 - Last updated: 2016-03-01"
            exit 0
            ;;
        --format)
            echo "$1 is unsupported. Please choose your format in screenr's config file. Skipping" >&2
            shift
            ;;
        --upload)
            shift
            if [[ ! -z "$upload_flag" ]]; then
                echo "Specifying multiple uploaders in 1 command is currently unsupported. Ignoring $1" >&2
            elif test $# -gt 0; then
                upload_flag="$1"
            else
                echo "No uploader specified. Aborting" >&2
                exit 1
            fi
            shift
            ;;
        --save)
            save_flag=1
            shift
            ;;
        *)
            break
            ;;
    esac
done
mkdir "/tmp/screenr" #directory where temporary files will be created; removed at the end of the script during cleanup
image_name=$(date "$date_format")."$img_format" #Name of the image file
full_path=/tmp/screenr/"$image_name" #Full path to the image file
# If -s|--select flag is passed, this sets a flag that is used to
# notify the user that Screenshot Selection Mode has been entered
# and to add the option to "Retake" a screenshot
if [[ $(echo "$@ " | grep -e '-s \|--select') ]]; then
    selection_mode=1
fi
take_screenshot "$@"
# Acts on specified flags and if none were passed it goes to menu to let user decide manually
if [[ ! -z "$upload_flag" || ! -z "$save_flag" ]]; then
    if [[ $save_flag == "1" ]]; then
        save
    fi
    if [[ ! -z "$upload_flag" ]]; then
        if [[ $upload_flag == "imgur" ]]; then
            imgur_upload
        elif [[ $upload_flag == "dropbox" ]]; then
            dropbox_upload
        else
            echo "Unsupported/unknown uploader $upload_flag. Skipping upload" >&2
        fi
    fi
else
    if [[ "$selection_mode" -eq 1 ]]; then #if selection flag was passed, this displays additional option to 'Retake' screenshot
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nRetake\nDiscard" | rofi -dmenu -p "Screenshot taken. What now? > ")
    else
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nDiscard" | rofi -dmenu -p "Screenshot taken. What now? > ")
    fi
    menu "$@"
fi
#If the image was uploaded, this copies the url into xsel or xclip
if [ -e /tmp/screenr/tmp_url -a "$clipping" -ne 0 ];then
    { type xsel >/dev/null 2>&1 && cat /tmp/screenr/tmp_url | head -n 1 | xsel -i; } \
        || { type xclip >/dev/null 2>&1 && cat /tmp/screenr/tmp_url | head -n 1 | xclip -i; } \
        || echo "Can't copy into clipboard: no xsel or xclip" >&2
fi
#If logging is enabled this appends the necessary information to the log_file
#If not information is only output to STDOUT and STDERR
if [[ "$logging" -ne 0 ]]; then
    echo $(date "$date_format") >> "$log_file"
    echo "$url_name" | tee -a "$log_file"
    if [[ -e /tmp/screenr/tmp_url_del ]]; then
        tee -a "$log_file" >&2 < /tmp/screenr/tmp_url_del
    fi
    echo >> "$log_file"
else
    echo "$url_name"
    if [[ -e /tmp/screenr/tmp_url_del ]]; then
        cat /tmp/screenr/tmp_url_del >&2
    fi
fi
cleanup
exit 0
