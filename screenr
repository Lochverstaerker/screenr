#!/bin/bash

# Visit https://github.com/Lochverstaerker/screenr for more information

source /etc/screenr/screenr.conf

if [[ ! -d $HOME/.config/screenr ]]; then
    mkdir $HOME/.config/screenr
fi

if [[ ! -f $HOME/.config/screenr/config ]]; then
    cp /etc/screenr/screenr.conf $HOME/.config/screenr/config
fi

source $HOME/.config/screenr/config

function usage {
    cat << EOF
screenr - a rofi-driven screenshot tool

https://github.com/Lochverstaerker/screenr

Usage: screenr [options]

screenr is a utility that takes screenshots using maim (+ slop)
and then opens a rofi-driven interactive menu to let the user decide what to do with the screenshot.

    -h, --help                      Show this information and exit
    -V, --version                   Show version information and exit
Options
        --upload UPLOADER           Skip the interactive menu and upload directly
                                        to UPLOADER (imgur or dropbox).
        --save                      Skip the interactive menu and save directly.
Additional Options
        (Almost) all the maim (+ slop) Options, see maim --help or man maim for help

Examples
    $ # Screenshot a selection and open interactive menu
    $ screenr -s

    $ # Screenshot the screen and save it, without opening interactive menu
    $ screenr --save

    $ # Screenshot currently active window and upload it to imgur,
    $ # without opening interactive window
    $ screenr -i \$(xdotool getactivewindow) --upload imgur
EOF
}

# Cleans up all the temporary files created during this script
function cleanup {
    shred -u /tmp/screenr/*
    rm -r /tmp/screenr
}

# Saves the screenshot to the image directory of the user
function save {
    cp "$full_path" "$image_dir"
    notify-send -u normal "Image saved" "$image_name"
}

# Must be called (immediately) after setting "$url_name";
# If a browser is defined in the config, this opens "$url_name" with it
function open_in_browser {
    if [ ! -z "$browser" ]; then
        if hash $(echo "$browser" | cut -f 1 -d " ") 2>/dev/null; then
            $browser $url_name
        else
            echo "Web browser not found." >&2
        fi
    fi
}

# If imgur is installed, this uploads the screenshot to it; otherwise an error is displayed in STDERR
# Optionally the site is opened in a web browser
function imgur_upload {
    if hash imgur 2>/dev/null; then
        imgur "$full_path" > /tmp/screenr/tmp_url 2> /tmp/screenr/tmp_url_del
        url_name=$(head -n 1 < /tmp/screenr/tmp_url)
        notify-send -u normal "Image uploaded" "$url_name"
        open_in_browser
    else
        echo "Can't upload to imgur, because the necessary script can't be found" >&2
    fi
}

# Copies the screenshot into the users dropbox directory, if dropbox-cli is installed there is added (optional) functionality:
# Tries to get puburl and if that is not possible gets sharelink, then (optionally) copies that into clipboard and opens it in web browser
function dropbox_upload {
    cp "$full_path" "$db_dir"
    printf "$db_dir/" >> "/tmp/screenr/db_path"; printf "$image_name" >> "/tmp/screenr/db_path"
    db_path=$(</tmp/screenr/db_path)
    notify-send -u normal "Image copied into dropbox" "$image_name"
    if hash dropbox-cli 2>/dev/null; then
        dropbox-cli puburl "$db_path" > /tmp/screenr/tmp_url
        if [[ $(grep "Error" < /tmp/screenr/tmp_url) ]]; then
            dropbox-cli sharelink "$db_path" > /tmp/screenr/tmp_url
        fi
        url_name=$(</tmp/screenr/tmp_url)
        if [[ "$db_waiting" -ne 0 ]]; then
            while [[ $(dropbox-cli filestatus "$db_path" | grep "syncing") ]]; do
                sleep "$check_interval"
            done
        fi
            open_in_browser
    else
        echo "Can't make use of additional dropbox related functionality, because the necessary script can't be found" >&2
    fi
}

# Menu to decide about where to upload screenshot; ESC or back cancels and goes back to (the previous) menu
# "$@" for added functionality to 'Retake' screenshots
function upload_menu {
    if [[ -z "$uploader" ]]; then #if ESC is pressed variable is not initialized
        uploader="$uploader_"     #falls back to default value
    fi
    if [[ $uploader == "Imgur" ]]; then
        imgur_upload
    fi
    if [[ $uploader == "Dropbox" ]]; then
        dropbox_upload
    fi
    if [[ $uploader == "Back" ]]; then
        unset choice
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nDiscard" | rofi -dmenu -p "Screenshot taken. What now? > ")
        menu "$@"
    fi
    if [[ $uploader == "Exit" ]]; then
        cleanup
        exit 0
    fi
}

# Makes a screenshot with specified flags; if -s is provided and interrupted by a keyboard interrupt, this cancels the script
function take_screenshot {
    if [[ $selection_mode == "1" ]]; then
        notify-send -t 1 -u low "Entered Screenshot Selection Mode"
    fi
    maim "$@" "$full_path" 2> /tmp/screenr/maim_err
    if [[ $(grep "Canceled selection" < /tmp/screenr/maim_err) ]]; then
        notify-send -t 1 -u low "Canceled"
        cleanup
        exit 0
    fi
    if [[ $(grep "invalid" < /tmp/screenr/maim_err) ]]; then
        cat /tmp/screenr/maim_err >&2
        echo "Maim encountered an error. Aborting" >&2
        cleanup
        exit 1
    fi
}

# Menu to decide what to do
# "$@" for added functionality to 'Retake' screenshots
# Every time a program is called, it is first checked if it exists and if not an error is directed to STDERR
function menu {
    if [[ $choice == "Save" ]]; then
        save
    fi
    if [[ $choice == "Upload" ]]; then
        unset uploader
        uploader=$(echo -e "Imgur\nDropbox\nBack" | rofi -dmenu -p "Where to upload? > ")
        uploader_="Back" #default choice
        upload_menu "$@"
    fi
    if [[ $choice == "Edit" ]]; then
        if hash $(echo "$img_prg" | cut -f 1 -d " ") 2>/dev/null; then #cut to remove flags that may be passed with the program
            $img_prg "$full_path"
        else
            echo "Image Manipulation Program not found" >&2
        fi
        unset choice
        choice=$(echo -e "Save\nUpload\nSave & Upload\nView\nDiscard" | rofi -dmenu -p "Image edited. What now? > ")
        menu "$@"
    fi
    if [[ $choice == "Save & Upload" ]]; then
        save
        uploader=$(echo -e "Imgur\nDropbox\nExit" | rofi -dmenu -p "Where to upload? > ")
        uploader_="Exit" #default choice
        upload_menu "$@"
    fi
    if [[ $choice == "View" ]]; then
        if hash $(echo "$img_view" | cut -f 1 -d " ") 2>/dev/null; then #cut to remove flags that may be passed with the program
            $img_view "$full_path"
        else
            echo "Image Viewer not found" >&2
        fi
        unset choice
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nRetake\nDiscard" | rofi -dmenu -p "What now? > ")
        menu "$@"
    fi
    if [[ $choice == "Retake" ]]; then
        take_screenshot "$@"
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nRetake\nDiscard" | rofi -dmenu -p "Screenshot taken. What now? > ")
        menu "$@"
    fi
    if [[ $choice == "Discard" || -z "$choice" ]]; then
        notify-send -u normal "Image discarded"
        cleanup
        exit 0
    fi
}

# Checks for certain flags that are handled by the script itself and not by maim
while test $# -gt 0; do
    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -V|--version)
            echo "screenr v1.0"
            echo "https://github.com/Lochverstaerker/screenr"
            exit 0
            ;;
        --format)
            echo "$1 is unsupported. Please choose your format in screenr's config file. Skipping" >&2
            shift
            ;;
        --upload)
            shift
            if [[ ! -z "$upload_flag" ]]; then
                echo "Specifying multiple uploaders in 1 command is currently unsupported. Ignoring $1" >&2
            elif test $# -gt 0; then
                upload_flag="$1"
            else
                echo "No uploader specified. Aborting" >&2
                exit 1
            fi
            shift
            ;;
        --save)
            save_flag=1
            shift
            ;;
        *)
            break
            ;;
    esac
done
mkdir "/tmp/screenr" #directory where temporary files will be created; removed at the end of the script during cleanup
image_name=$(date "$date_format")."$img_format" #Name of the image file
full_path=/tmp/screenr/"$image_name" #Full path to the image file
# If -s|--select flag is passed, this sets a flag that is used to
# notify the user that Screenshot Selection Mode has been entered
# and to add the option to "Retake" a screenshot
if [[ $(echo "$@ " | grep -e '-s \|--select') ]]; then
    selection_mode=1
fi
take_screenshot "$@"
# Acts on specified flags and if none were passed it goes to menu to let user decide manually
if [[ ! -z "$upload_flag" || ! -z "$save_flag" ]]; then
    if [[ $save_flag == "1" ]]; then
        save
    fi
    if [[ ! -z "$upload_flag" ]]; then
        if [[ $upload_flag == "imgur" ]]; then
            imgur_upload
        elif [[ $upload_flag == "dropbox" ]]; then
            dropbox_upload
        else
            echo "Unsupported/unknown uploader $upload_flag. Skipping upload" >&2
        fi
    fi
else
    if [[ "$selection_mode" -eq 1 ]]; then #if selection flag was passed, this displays additional option to 'Retake' screenshot
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nRetake\nDiscard" | rofi -dmenu -p "Screenshot taken. What now? > ")
    else
        choice=$(echo -e "Save\nUpload\nEdit\nSave & Upload\nView\nDiscard" | rofi -dmenu -p "Screenshot taken. What now? > ")
    fi
    menu "$@"
fi
#If the image was uploaded, this copies the url into xsel or xclip
if [ -e /tmp/screenr/tmp_url -a "$clipping" -ne 0 ];then
    { type xsel >/dev/null 2>&1 && cat /tmp/screenr/tmp_url | head -n 1 | xsel -i; } \
        || { type xclip >/dev/null 2>&1 && cat /tmp/screenr/tmp_url | head -n 1 | xclip -i; } \
        || echo "Can't copy into clipboard: no xsel or xclip" >&2
fi
#If a screenshot was taken and
#logging is enabled this appends the necessary information to the log_file
#If not information is only output to STDOUT and STDERR
if [[ ! -z "$url_name" ]]; then
    if [[ "$logging" -ne 0 ]]; then
        echo $(date "$date_format") >> "$log_file"
        echo "$url_name" | tee -a "$log_file"
        if [[ -e /tmp/screenr/tmp_url_del ]]; then
            tee -a "$log_file" >&2 < /tmp/screenr/tmp_url_del
        fi
        echo >> "$log_file"
    else
        echo "$url_name"
        if [[ -e /tmp/screenr/tmp_url_del ]]; then
            cat /tmp/screenr/tmp_url_del >&2
        fi
    fi
fi
cleanup
exit 0
